#!/bin/bash
# Authors (2026): G. Quargnali & P. Rivera-Fuentes @ LOCBP (https://www.locbp.com/) University of Zurich Switzerland
#
# This software is freely available for use, modification, and redistribution.

#
# Local Execution Script for BioPipelines
#
# This script runs a BioPipelines pipeline locally (without SLURM),
# executing the generated bash scripts directly.
#
# Usage:
#     ./run <pipeline_script>
#

# Get the directory where this script is located (biopipelines root)
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
CONFIG_FILE="$SCRIPT_DIR/config.yaml"
# Read env_manager from config.yaml
ENV_MANAGER=$(grep '^\s*env_manager:' "$CONFIG_FILE" 2>/dev/null | head -1 | sed 's/.*env_manager:\s*["'\'']\{0,1\}\([a-zA-Z]*\)["'\'']\{0,1\}.*/\1/' | tr -d '[:space:]')
if [ -z "$ENV_MANAGER" ]; then
    echo "ERROR: env_manager not found in config.yaml (cluster section)"
    echo "Please add 'env_manager: mamba' (or conda) under 'cluster:' in $CONFIG_FILE"
    exit 1
fi

# Initialize environment manager
if command -v $ENV_MANAGER &> /dev/null; then
    if [ "$ENV_MANAGER" = "conda" ]; then
        eval "$(conda shell.bash hook)"
    else
        eval "$($ENV_MANAGER shell hook --shell bash)"
    fi
elif command -v conda &> /dev/null; then
    echo "Warning: $ENV_MANAGER not found, falling back to conda"
    ENV_MANAGER="conda"
    eval "$(conda shell.bash hook)"
else
    echo "ERROR: Neither $ENV_MANAGER nor conda found in PATH"
    echo "Please install miniforge/mambaforge or conda first"
    exit 1
fi

set -e  # Exit on any error

# Check if biopipelines env exists
if $ENV_MANAGER env list 2>/dev/null | grep -qw "biopipelines"; then
    echo "Activating biopipelines environment..."
    $ENV_MANAGER activate biopipelines
else
    echo "ERROR: biopipelines environment not found."
    echo ""
    echo "Please install it first (see Docs/UserManual.md):"
    echo "  $ENV_MANAGER env create -f Environments/biopipelines.yaml"
    echo "  $ENV_MANAGER activate biopipelines"
    echo "  pip install -e ."
    exit 1
fi
echo ""

# Function to print usage
usage() {
    echo "Usage: $0 [-v|--verbose] <pipeline_script>"
    echo ""
    echo "Run a BioPipelines pipeline locally (without SLURM)"
    echo ""
    echo "Options:"
    echo "  -v, --verbose    Show full pipeline generation output"
    echo ""
    echo "Arguments:"
    echo "  pipeline_script  Path to pipeline script (.py or .ipynb)"
    echo ""
    echo "Examples:"
    echo "  $0 pipeline.py"
    echo "  $0 -v pipeline.py                            # Run with full output"
    echo "  $0 pipeline.ipynb                             # Run from notebook"
    echo "  $0 ExamplePipelines/boltz2.py"
    echo ""
}

# Function to run pipeline and execute locally
run_pipeline_locally() {
    local pipeline_script="$1"
    local verbose="$2"

    echo "Generating pipeline: $pipeline_script"

    # Run the pipeline Python script to generate bash scripts
    local pipeline_output=$(python "$pipeline_script" 2>&1)
    local exit_code=$?

    if [ "$verbose" = "1" ]; then
        echo ""
        echo "$pipeline_output"
    else
        # Even in non-verbose mode, show full tracebacks and error context
        local error_output=$(echo "$pipeline_output" | awk '
            /^Traceback \(most recent call last\)/ { capture=1 }
            capture { print }
            !capture && /^[A-Za-z]*[Ee]rror:|^[A-Za-z]*[Ee]xception:/ { print }
        ')
        if [ -n "$error_output" ]; then
            echo ""
            echo "$error_output"
        fi
    fi
    echo ""

    if [ $exit_code -ne 0 ]; then
        echo "Pipeline generation failed with exit code $exit_code"
        if [ "$verbose" != "1" ]; then
            echo "Re-run with -v to see full output"
        fi
        return 1
    fi

    # Extract ALL runtime directories from pipeline output
    local runtime_dirs=$(echo "$pipeline_output" | grep -o '/[^ ]*/RunTime' | sort -u)

    if [ -z "$runtime_dirs" ]; then
        echo "No runtime directories found in pipeline output"
        return 1
    fi

    echo ""
    echo "Found $(echo "$runtime_dirs" | wc -l) pipeline(s) to execute locally"
    echo "=========================================="
    echo ""

    local total_pipelines_run=0

    # Process each runtime directory
    while IFS= read -r runtime_dir; do
        if [ -z "$runtime_dir" ] || [ ! -d "$runtime_dir" ]; then
            continue
        fi

        local pipeline_name=$(basename "$(dirname "$runtime_dir")")
        echo "Processing pipeline: $pipeline_name"
        echo "Runtime directory: $runtime_dir"
        echo ""

        # Check for batch files (multi-batch pipeline)
        local batch_files=$(ls "$runtime_dir"/pipeline_batch*.sh 2>/dev/null | sort -V)

        if [ -n "$batch_files" ]; then
            # Multi-batch pipeline - execute sequentially
            echo "Detected multi-batch pipeline"
            echo "Executing batches sequentially..."
            echo "------------------------------------------"
            echo ""

            local batch_count=0
            for batch_file in $batch_files; do
                batch_count=$((batch_count + 1))
                local batch_num=$(basename "$batch_file" | grep -o '[0-9]\+')
                echo "Executing batch $batch_num..."
                echo "  Script: $batch_file"

                bash "$batch_file"
                local batch_exit=$?

                if [ $batch_exit -eq 0 ]; then
                    echo "Batch $batch_num completed successfully"
                else
                    echo "Batch $batch_num failed with exit code $batch_exit"
                    return 1
                fi
                echo ""
            done

            echo "Pipeline $pipeline_name: $batch_count batch(es) executed"
            total_pipelines_run=$((total_pipelines_run + 1))
        else
            # Single batch pipeline - look for pipeline.sh
            local pipeline_sh="$runtime_dir/pipeline.sh"
            if [ -f "$pipeline_sh" ]; then
                echo "Detected single-batch pipeline"
                echo "Executing pipeline..."
                echo "------------------------------------------"
                echo ""

                bash "$pipeline_sh"
                local run_exit=$?

                if [ $run_exit -eq 0 ]; then
                    echo "Pipeline completed successfully"
                else
                    echo "Pipeline failed with exit code $run_exit"
                    return 1
                fi

                total_pipelines_run=$((total_pipelines_run + 1))
            else
                echo "Warning: No pipeline script found in $runtime_dir"
            fi
        fi
        echo ""
    done <<< "$runtime_dirs"

    echo "=========================================="
    echo "All pipelines executed. Total: $total_pipelines_run"
}

# Main execution
main() {
    local verbose=0
    local pipeline_script=""

    echo "BioPipelines Local Execution Script"
    echo "===================================="
    echo ""

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                usage
                return 0
                ;;
            -v|--verbose)
                verbose=1
                shift
                ;;
            *)
                pipeline_script="$1"
                shift
                ;;
        esac
    done

    # Require a pipeline script argument
    if [ -z "$pipeline_script" ]; then
        echo "Error: No pipeline script specified"
        echo ""
        usage
        return 1
    fi

    # Check if pipeline script exists
    if [ ! -f "$pipeline_script" ]; then
        echo "Error: Pipeline script not found: $pipeline_script"
        return 1
    fi

    # Run the pipeline locally
    run_pipeline_locally "$pipeline_script" "$verbose"
}

# Run main function with all arguments
main "$@"
