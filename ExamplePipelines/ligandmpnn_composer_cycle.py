"""
This pipeline shows how improve the difference in predicted binding affinity between open and close form of a carbocyanine 7 chloride and halotag7 starting from a Boltz model of the open form.
"""

import os, sys
sys.path.insert(0, os.getcwd()) #to see scripts in current folder

from PipelineScripts.pipeline import *
from PipelineScripts.load_output import LoadOutput
from PipelineScripts.ligand_mpnn import LigandMPNN
from PipelineScripts.mutation_profiler import MutationProfiler
from PipelineScripts.mutation_composer import MutationComposer
from PipelineScripts.boltz2 import Boltz2
from PipelineScripts.residue_atom_distance import ResidueAtomDistance
from PipelineScripts.panda import Panda
from PipelineScripts.plot import Plot
from PipelineScripts.pymol import PyMOL

with Pipeline(project="Examples",
              job="LigandMPNN-MutationComposer-Cycle",
              description="Profiling of mutations occuring over 1000 sequences generated by LigandMPNN and composition of sequences based on it, cycling to improve difference in affinity between open and bound"):

    Resources(gpu="any",
              time="24:00:00",
              memory="16GB")

    original_open = LoadOutput('/shares/locbp.chem.uzh/public/BioPipelines/Boltz/HT7_Cy7_C_R_001/ToolOutputs/1_Boltz2_output.json')
    original_close = LoadOutput('/shares/locbp.chem.uzh/public/BioPipelines/Boltz/HT7_Cy7_C_RR_001/ToolOutputs/1_Boltz2_output.json')

    best_open, best_close = original_open, original_close

    # Merge original open and close affinity tables with Panda
    original_analysis = Panda(
        tables=[best_open.tables.affinity, best_close.tables.affinity],
        operations=[
            Panda.merge(on="id", prefixes=["open_", "close_"], id_map={"original": ["HT7_Cy7_C_R", "HT7_Cy7_C_RR"]}),
            Panda.calculate({"affinity_delta": "open_affinity_pred_value - close_affinity_pred_value"})
        ]
    )

    NUM_CYCLES = 3
    all_sequences_seen = None  # Track all sequences across cycles

    # Track all analyses and pools across cycles for best selection
    all_analyses = [original_analysis]  # Start with original baseline
    all_pools = [best_open]  # Start with original best structure

    for CYCLE in range(NUM_CYCLES):
        Suffix(f"Cycle{CYCLE+1}")

        mutation_range = "141+143+145+147-149+151-152+154+157+160-161+165+167-168+170-172+175-176+178+180+245+271"
        lmpnn = LigandMPNN(structures=best_open,
                          ligand="LIG",  # LIG is the ligand name from Boltz
                          num_sequences=1000,
                          batch_size=25,
                          redesigned=mutation_range)

        profiler = MutationProfiler(original=best_open,
                                    mutants=lmpnn)
        composer = MutationComposer(frequencies=profiler.tables.absolute_frequencies,
                                    num_sequences=3,
                                    mode="weighted_random",
                                    max_mutations=3)

        # Remove duplicates using Panda drop_duplicates with pool mode to preserve sequences
        if all_sequences_seen is None:
            # First cycle - just deduplicate within current batch
            unique_new_sequences = Panda(
                table=composer.tables.sequences,
                operations=[Panda.drop_duplicates(subset="sequence", keep="first")],
                pool=composer  # Pool mode copies sequence files for filtered IDs
            )
            # Initialize history (table only, no pool needed)
            all_sequences_seen = Panda(
                table=unique_new_sequences.tables.result,
                operations=[]
            )
        else:
            # Subsequent cycles - concatenate with history and remove duplicates
            combined = Panda(
                tables=[composer.tables.sequences, all_sequences_seen.tables.result],
                operations=[Panda.concat(add_source=True)]
            )
            unique_new_sequences = Panda(
                table=combined.tables.result,
                operations=[
                    Panda.drop_duplicates(subset="sequence", keep="first"),
                    Panda.filter("source_table == 0")  # Keep only new sequences (source_table is int)
                ],
                pool=composer  # Pool mode copies sequence files for filtered IDs
            )
            # Update history (table only, no pool needed)
            all_sequences_seen = Panda(
                table=combined.tables.result,
                operations=[Panda.drop_duplicates(subset="sequence", keep="first")]
            )

        boltz_holo_open = Boltz2(proteins=unique_new_sequences,
                                 ligands=original_open)
        boltz_holo_close = Boltz2(proteins=unique_new_sequences,
                                  ligands=original_close,
                                  msas=boltz_holo_open)

        open_chlorine_aspartate_distance = ResidueAtomDistance(structures=boltz_holo_open,
                                                               residue='D in IHDWG',
                                                               atom='LIG.Cl',
                                                               metric_name='open_chlorine_distance')
        open_cap_aspartate_distance = ResidueAtomDistance(structures=boltz_holo_open,
                                                          residue='D in IHDWG',
                                                          atom='LIG.N88',
                                                          metric_name='open_cap_distance')

        # Merge all metrics with Panda
        current_analysis = Panda(
            tables=[boltz_holo_open.tables.affinity,
                    boltz_holo_close.tables.affinity,
                    open_chlorine_aspartate_distance.tables.analysis,
                    open_cap_aspartate_distance.tables.analysis],
            operations=[
                Panda.merge(on="id", prefixes=["open_", "close_", "", ""]),
                Panda.calculate({"affinity_delta": "open_affinity_pred_value - close_affinity_pred_value"})
            ]
        )

        # Filter using Panda
        current_filtered = Panda(
            table=current_analysis.tables.result,
            operations=[Panda.filter("open_chlorine_distance < 5.0 and open_cap_distance > 10.0")]
        )

        # Add current cycle results to the arrays
        all_pools.append(boltz_holo_open)
        all_analyses.append(current_filtered)

        # Select best structure across all cycles using Panda with multi-pool support
        best_open = Panda(
            tables=[x.tables.result for x in all_analyses],
            operations=[
                Panda.concat(add_source=True),  # source_table column tracks which pool
                Panda.sort("open_affinity_pred_value", ascending=True),  # min = ascending
                Panda.head(1)
            ],
            pool=[pool for pool in all_pools],  # Multiple pools matching tables
            rename=f"{CYCLE+1}_best"
        )

    """
    Some plotting
    """

    # Concatenate all cycle results and compute averages using Panda
    all_result_tables = [x.tables.result for x in all_analyses]
    combined_results = Panda(
        tables=all_result_tables,
        operations=[Panda.concat(add_source=True)]
    )

    # Average metrics by cycle (source table)
    cycle_averages = Panda(
        table=combined_results.tables.result,
        operations=[Panda.average_by_source()]
    )

    # Generate plots showing optimization progress across cycles
    Plot(
        # Affinity delta distribution across all cycles
        Plot.Histogram(
            data=combined_results.tables.result,
            x="affinity_delta",
            bins=30,
            title="Affinity Delta Distribution (All Cycles)",
            xlabel="Affinity Delta (Open - Close)",
            ylabel="Count"
        ),
        # Scatter: open vs close affinity
        Plot.Scatter(
            data=combined_results.tables.result,
            x="open_affinity_pred_value",
            y="close_affinity_pred_value",
            color="source_table",
            title="Open vs Close Affinity by Cycle",
            xlabel="Open Affinity",
            ylabel="Close Affinity",
            grid=True
        ),
        # Scatter: chlorine distance vs affinity delta
        Plot.Scatter(
            data=combined_results.tables.result,
            x="open_chlorine_distance",
            y="affinity_delta",
            title="Chlorine-Aspartate Distance vs Affinity Delta",
            xlabel="Cl-Asp Distance (Ã…)",
            ylabel="Affinity Delta",
            grid=True
        )
    )

    # PyMOL renders of best structures from final cycle
    PyMOL(
        PyMOL.RenderEach(
            structures=best_open,
            orient_selection="hetatm",
            color_protein="plddt",
            color_ligand="byatom",
            ligand_selection="hetatm",
            plddt_upper=1,  # Boltz2 uses 0-1 confidence scores
            title="HaloTag7-Cy7 | Affinity: {open_affinity_pred_value:.2f} | Delta: {affinity_delta:.2f}",
            title_table=best_open.tables.affinity,
            width=1920,
            height=1080,
            background="white"
        ),
        session="best_open_renders"
    )

