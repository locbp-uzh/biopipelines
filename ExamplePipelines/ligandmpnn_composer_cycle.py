# Copyright (c) 2026 Gianluca Quargnali @ LOCBP (https://www.locbp.com/) University of Zurich Switzerland
#
# Licensed under the MIT License. See LICENSE file in the project root for details.

"""
This pipeline shows how improve the difference in predicted binding affinity between benzamide and triazole chloroalkanes and halotag7 starting from a Boltz model of both.
"""

from PipelineScripts.pipeline import *
from PipelineScripts.entities import *
from PipelineScripts.ligand_mpnn import LigandMPNN
from PipelineScripts.mutation_profiler import MutationProfiler
from PipelineScripts.mutation_composer import MutationComposer
from PipelineScripts.boltz2 import Boltz2
from PipelineScripts.distance import Distance
from PipelineScripts.panda import Panda
from PipelineScripts.plot import Plot
from PipelineScripts.pymol import PyMOL

# This function will be used to make sure new sequences generated at each cycle haven't been folded before
def drop_duplicates_history(new_sequences, all_sequences_seen):
    if all_sequences_seen is None:
        # First cycle - just deduplicate within current batch
        unique_new_sequences = Panda(
            table=new_sequences.tables.sequences,
            operations=[Panda.drop_duplicates(subset="sequence", keep="first")],
            pool=new_sequences  # Pool mode copies sequence files for filtered IDs
        )
        # Initialize history (table only, no pool needed)
        all_sequences_updated = Panda(
            table=unique_new_sequences.tables.result,
            operations=[]
        )
    else:
        # Subsequent cycles - concatenate with history and remove duplicates
        combined = Panda(
            tables=[new_sequences.tables.sequences, all_sequences_seen.tables.result],
            operations=[Panda.concat(add_source=True)]
        )
        unique_new_sequences = Panda(
            table=combined.tables.result,
            operations=[
                Panda.drop_duplicates(subset="sequence", keep="first"),
                Panda.filter("source_table == 0")  # Keep only new sequences (source_table is int)
            ],
            pool=new_sequences  # Pool mode copies sequence files for filtered IDs
        )
        # Update history (table only, no pool needed)
        all_sequences_updated = Panda(
            table=combined.tables.result,
            operations=[Panda.drop_duplicates(subset="sequence", keep="first")]
        )
    return unique_new_sequences,all_sequences_updated

with Pipeline(project="Examples",
              job="LigandMPNN-MutationComposer-Cycle",
              description="Profiling of mutations occuring over 1000 sequences generated by LigandMPNN and composition of sequences based on it, cycling to improve difference in affinity between open and bound"):

    Resources(gpu="any",
              time="4:00:00",
              memory="16GB")
    
    HaloTag = Sequence("MAEIGTGFPFDPHYVEVLGERMHYVDVGPRDGTPVLFLHGNPTSSYVWRNIIPHVAPTHRCIAPDLIGMGKSDKPDLGYFFDDHVRFMDAFIEALGLEEVVLVIHDWGSALGFHWAKRNPERVKGIAFMEFIRPIPTWDEWPEFARETFQAFRTTDVGRKLIIDQNVFIEGTLPMGVVRPLTEVEMDHYREPFLNPVDREPLWRFPNELPIAGEPANIVALVEEYMDWLHQSPVPKLLFWGTPGVLIPPAEAARLAKSLPNCKAVDIGPGLNLLQEDNPDLIGSEIARWLSTLEISG",
                       ids="HT")
    
    benzamide = Ligand(smiles=r"O=C(C1=CC=CC=C1)NCCOCCOCCCCCCCl",
                        ids="BENZAMIDE")
    triazole  = Ligand(smiles=r"ClCCCCCCOCCOCCN1C=C(C)N=N1",
                        ids="TRIAZOLE")

    # We need an initial prediction from Boltz to benchmark the affinities
    original_benzamide = Boltz2(proteins=HaloTag,
                       ligands=benzamide)
    original_triazole = Boltz2(proteins=HaloTag,
                       ligands=triazole,
                       msas=original_benzamide)
    ## At this point, one can inspect the structure to verify the ligand atom names, and use those names for later analysis (e.g. distance or filter)

    # Merge original open and close affinity tables with Panda
    # pool=best_benzamide preserves structure files with id_map remapped IDs
    original_analysis = Panda(
        tables=[original_benzamide.tables.affinity, original_triazole.tables.affinity],
        operations=[
            Panda.merge(on="id", prefixes=["benzamide_", "triazole_"], id_map={"original": [original_benzamide.streams.structures.ids[0],original_triazole.streams.structures.ids[0]]}),
            Panda.calculate({"affinity_delta": "benzamide_affinity_pred_value - triazole_affinity_pred_value"})
        ],
        pool=original_benzamide # this way we have the original open pdb file linked to the id "original". it is necessary in case the best of the first cycle(s) is that.
    )

    NUM_CYCLES = 3
    all_sequences_seen = None  # Track all sequences across cycles

    # Track all analyses and pools across cycles for best selection
    all_analyses = [original_analysis]  # Start with original baseline
    all_pools = [original_benzamide]  # Start with original best structure

    best_benzamide,best_triazole=original_benzamide,original_triazole


    for CYCLE in range(NUM_CYCLES):
        Suffix(f"Cycle{CYCLE+1}")

        mutation_range = "141+143+145+147-149+151-152+154+157+160-161+165+167-168+170-172+175-176+178+180+245+271" # se could have used DistanceSelector for a dynamic choise
        lmpnn = LigandMPNN(structures=best_benzamide,
                          ligand="LIG",  # LIG is the ligand name from Boltz
                          num_sequences=1000,
                          batch_size=25,
                          redesigned=mutation_range)

        profiler = MutationProfiler(original=best_benzamide,
                                    mutants=lmpnn)
        composer = MutationComposer(frequencies=profiler.tables.absolute_frequencies,
                                    num_sequences=3,
                                    mode="weighted_random",
                                    max_mutations=3)

        unique_new_sequences,all_sequences_seen=drop_duplicates_history(composer,all_sequences_seen)
        
        boltz_holo_benzamide = Boltz2(proteins=unique_new_sequences,
                                 ligands=benzamide)
        boltz_holo_triazole = Boltz2(proteins=unique_new_sequences,
                                  ligands=triazole,
                                  msas=boltz_holo_benzamide)

        benzamide_chlorine_aspartate_distance = Distance(structures=boltz_holo_benzamide,
                                                               residue='D in IHDWG', #importantly: we are not mutating the context around the aspartate
                                                               atom='LIG.Cl',
                                                               metric_name='benzamide_chlorine_distance')
        triazole_chlorine_aspartate_distance = Distance(structures=boltz_holo_triazole,
                                                               residue='D in IHDWG',
                                                               atom='LIG.Cl',
                                                               metric_name='triazole_chlorine_distance')

        # Merge all metrics with Panda
        current_analysis_filtered = Panda(
            tables=[boltz_holo_benzamide.tables.affinity,
                    boltz_holo_triazole.tables.affinity,
                    benzamide_chlorine_aspartate_distance.tables.distances,
                    triazole_chlorine_aspartate_distance.tables.distances],
            operations=[
                Panda.merge(on="id", prefixes=["benzamide_", "triazole_", "", ""]),
                Panda.calculate({"affinity_delta": "benzamide_affinity_pred_value - triazole_affinity_pred_value"}),
                Panda.filter("benzamide_chlorine_distance < 5.0 and triazole_chlorine_distance < 5.0") #exclude odd poses
            ]
        )

        # Add current cycle results to the arrays
        all_pools.append(boltz_holo_benzamide)
        all_analyses.append(current_analysis_filtered)

        # Select best structure across all cycles using Panda with multi-pool support
        best_benzamide = Panda(
            tables=[x.tables.result for x in all_analyses],
            operations=[
                Panda.concat(add_source=True),  # source_table column tracks which pool they come from
                Panda.sort("benzamide_affinity_pred_value", ascending=True),  # min = ascending
                Panda.head(1)
            ],
            pool=[pool for pool in all_pools],  # Multiple pools matching tables
            rename=f"{CYCLE+1}_best"
        )


    #Some plotting


    # Concatenate all cycle results and compute averages using Panda
    all_result_tables = [x.tables.result for x in all_analyses]
    combined_results = Panda(
        tables=all_result_tables,
        operations=[Panda.concat(add_source=True)]
    )

    # Average metrics by cycle (source table)
    cycle_averages = Panda(
        table=combined_results.tables.result,
        operations=[Panda.average_by_source()]
    )

    # Generate plots showing optimization progress across cycles
    Plot(
        # Affinity delta distribution across all cycles
        Plot.Histogram(
            data=combined_results.tables.result,
            x="affinity_delta",
            bins=30,
            title="Affinity Delta Distribution (All Cycles)",
            xlabel="Affinity Delta (Open - Close)",
            ylabel="Count"
        ),
        # Scatter: open vs close affinity
        Plot.Scatter(
            data=combined_results.tables.result,
            x="benzamide_affinity_pred_value",
            y="triazole_affinity_pred_value",
            color="source_table",
            title="Open vs Close Affinity by Cycle",
            xlabel="Open Affinity",
            ylabel="Close Affinity",
            grid=True
        ),
        # Scatter: chlorine distance vs affinity delta
        Plot.Scatter(
            data=combined_results.tables.result,
            x="benzamide_chlorine_distance",
            y="affinity_delta",
            title="Chlorine-Aspartate Distance vs Affinity Delta",
            xlabel="Cl-Asp Distance (Ã…)",
            ylabel="Affinity Delta",
            grid=True
        )
    )

    # We see the sequence alignment against the original protein with PyMOL
    PyMOL(
        PyMOL.ColorAlign(
            reference=original_benzamide,
            targets=best_benzamide
        )
    )

