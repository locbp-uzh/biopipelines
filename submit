#!/bin/bash
#
# SLURM Submission Script for BioPipelines
#
# This script submits a BioPipelines job to SLURM, mimicking the functionality
# of going to job composer and running the job with the suggested job name.
#
# Usage:
#     ./submit.sh <pipeline_script>
#

module load miniforge3
# miniforge3 automatically sources conda.sh
# source /apps/opt/spack/linux-ubuntu20.04-x86_64/gcc-9.3.0/mamba-23.11.0-0-334ztq7i4mzu762ew2x3kbbrrorhe6eg/etc/profile.d/conda.sh

# Initialize mamba for current shell session
eval "$(mamba shell hook --shell bash)"

set -e  # Exit on any error

# Get the directory where submit script is located (biopipelines root)
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ENV_FILE="$SCRIPT_DIR/Environments/biopipelines.yaml"

# Read required version from yaml header comment
if [ -f "$ENV_FILE" ]; then
    REQUIRED_VERSION=$(grep "^# Version:" "$ENV_FILE" | sed 's/# Version: //' | tr -d '[:space:]')
    if [ -z "$REQUIRED_VERSION" ]; then
        echo "ERROR: Could not parse version from $ENV_FILE"
        exit 1
    fi
else
    echo "ERROR: biopipelines.yaml not found"
    exit 1
fi

# Function to get installed version from conda env
get_installed_version() {
    local env_prefix=$(mamba run -n biopipelines printenv CONDA_PREFIX 2>/dev/null || echo "")
    if [ -n "$env_prefix" ] && [ -f "$env_prefix/.biopipelines_version" ]; then
        cat "$env_prefix/.biopipelines_version" | tr -d '[:space:]'
    else
        echo ""
    fi
}

# Function to store version in conda env
store_version() {
    local env_prefix=$(mamba run -n biopipelines printenv CONDA_PREFIX 2>/dev/null || echo "")
    if [ -n "$env_prefix" ]; then
        echo "$REQUIRED_VERSION" > "$env_prefix/.biopipelines_version"
        echo "Stored version $REQUIRED_VERSION in environment"
    fi
}

# Check if biopipelines env exists and has correct version
NEEDS_UPDATE=false
if mamba env list | grep -qw "biopipelines"; then
    INSTALLED_VERSION=$(get_installed_version)
    if [ "$INSTALLED_VERSION" = "$REQUIRED_VERSION" ]; then
        echo "biopipelines environment found (version $INSTALLED_VERSION)"
        echo "Activating biopipelines environment..."
        mamba activate biopipelines
    else
        echo "biopipelines environment version mismatch!"
        echo "  Installed: ${INSTALLED_VERSION:-unknown}"
        echo "  Required:  $REQUIRED_VERSION"
        NEEDS_UPDATE=true
    fi
else
    echo "biopipelines environment not found."
    NEEDS_UPDATE=true
fi

# Create or update environment if needed
if [ "$NEEDS_UPDATE" = true ]; then
    if [ -f "$ENV_FILE" ]; then
        if mamba env list | grep -qw "biopipelines"; then
            echo "Updating biopipelines environment to version $REQUIRED_VERSION..."
            mamba env update -n biopipelines -f "$ENV_FILE" --prune
        else
            echo "Creating biopipelines environment (version $REQUIRED_VERSION)..."
            mamba env create -f "$ENV_FILE"
        fi
        echo "Activating biopipelines environment..."
        mamba activate biopipelines
        store_version
    else
        echo "ERROR: biopipelines.yaml not found at $ENV_FILE"
        exit 1
    fi
fi
echo ""

# Function to print usage
usage() {
    echo "Usage: $0 <pipeline_script>"
    echo ""
    echo "Run a BioPipelines script and submit the generated job to SLURM"
    echo ""
    echo "Arguments:"
    echo "  pipeline_script  Path to pipeline script"
    echo ""
    echo "Examples:"
    echo "  $0 pipeline.py                               # Run pipeline.py"
    echo "  $0 ExamplePipelines/ligandmpnn_boltz2.py    # Run specific pipeline"
    echo ""
}

# Function to run pipeline and execute sbatch commands
run_pipeline_and_submit() {
    local pipeline_script="$1"

    echo "Running pipeline: $pipeline_script"
    echo ""

    # Run the pipeline and capture output
    local pipeline_output=$(python "$pipeline_script" 2>&1)
    local exit_code=$?

    # Show pipeline output
    echo "$pipeline_output"
    echo ""

    if [ $exit_code -ne 0 ]; then
        echo "Pipeline execution completed with exit code $exit_code"
        echo "Note: This is expected for dummy/test pipelines"
        echo ""
    fi

    # Extract ALL runtime directories from pipeline output
    local runtime_dirs=$(echo "$pipeline_output" | grep -o '/[^ ]*/RunTime' | sort -u)

    if [ -z "$runtime_dirs" ]; then
        echo "No runtime directories found in pipeline output"
        # Fall back to checking for sbatch commands (backward compatibility)
        local sbatch_commands=$(echo "$pipeline_output" | grep "^sbatch ")
        if [ -n "$sbatch_commands" ]; then
            echo ""
            echo "Submitting jobs..."
            echo "=========================================="
            echo ""

            local job_count=0
            while IFS= read -r sbatch_cmd; do
                if [ -n "$sbatch_cmd" ]; then
                    job_count=$((job_count + 1))
                    echo "Job $job_count:"
                    echo "$sbatch_cmd"
                    eval "$sbatch_cmd" || true
                    echo ""
                fi
            done <<< "$sbatch_commands"

            echo "=========================================="
            echo "All jobs submitted. Total: $job_count"
            return 0
        else
            return 1
        fi
    fi

    echo ""
    echo "Found $(echo "$runtime_dirs" | wc -l) pipeline(s) to submit"
    echo "=========================================="
    echo ""

    local total_jobs_submitted=0

    # Process each runtime directory
    while IFS= read -r runtime_dir; do
        if [ -z "$runtime_dir" ] || [ ! -d "$runtime_dir" ]; then
            continue
        fi

        # Extract pipeline name from runtime directory
        local pipeline_name=$(basename "$(dirname "$runtime_dir")")
        echo "Processing pipeline: $pipeline_name"
        echo "Runtime directory: $runtime_dir"
        echo ""

        # Check for batch files (multi-batch pipeline)
        local batch_files=$(ls "$runtime_dir"/slurm_batch*.sh 2>/dev/null | sort -V)

        if [ -n "$batch_files" ]; then
            # Multi-batch pipeline
            echo "Detected multi-batch pipeline"
            echo "Submitting jobs with dependencies..."
            echo "------------------------------------------"
            echo ""

            local job_count=0
            local last_job_id=""

            for batch_file in $batch_files; do
                job_count=$((job_count + 1))

                # Replace <JOBID> placeholder with previous job ID
                if [ -n "$last_job_id" ]; then
                    echo "Updating $batch_file with dependency on job $last_job_id"
                    sed -i "s/<JOBID>/$last_job_id/g" "$batch_file"
                    # Verify replacement worked
                    if grep -q "<JOBID>" "$batch_file"; then
                        echo "Warning: Failed to replace <JOBID> placeholder in $batch_file"
                    fi
                fi

                # Extract batch number for job naming
                local batch_num=$(basename "$batch_file" | grep -o '[0-9]\+')
                local job_name="${pipeline_name}_batch${batch_num}"
                local output_path="$runtime_dir/job_batch${batch_num}.out"

                # Submit and capture job ID
                echo "Submitting batch $batch_num..."
                echo "  Job name: $job_name"
                echo "  Output: $output_path"
                if [ -n "$last_job_id" ]; then
                    echo "  Dependency: afterok:$last_job_id"
                fi

                local submit_output=$(sbatch --parsable --job-name="$job_name" --output="$output_path" "$batch_file" 2>&1)
                local submit_exit=$?

                # Check for both exit code and error messages in output
                if [ $submit_exit -eq 0 ] && ! echo "$submit_output" | grep -qi "error\|invalid\|failed"; then
                    last_job_id="$submit_output"
                    echo "✓ Batch $batch_num submitted: Job ID $last_job_id"
                    total_jobs_submitted=$((total_jobs_submitted + 1))
                else
                    echo "✗ Failed to submit batch $batch_num"
                    echo "   Error: $submit_output"
                    return 1
                fi
                echo ""
            done

            echo "Pipeline $pipeline_name: $job_count batch(es) submitted"
            echo ""
        else
            # Single batch pipeline - look for slurm.sh
            local slurm_script="$runtime_dir/slurm.sh"
            if [ -f "$slurm_script" ]; then
                echo "Detected single-batch pipeline"
                echo "Submitting job..."
                echo "------------------------------------------"
                echo ""

                # Extract job name from pipeline output
                local job_name=$(echo "$pipeline_output" | grep -A1 "$runtime_dir" | grep -o "Job: .*" | sed 's/Job: //' | head -1)
                if [ -z "$job_name" ]; then
                    job_name="$pipeline_name"
                fi

                local output_path="$runtime_dir/slurm.out"
                local submit_output=$(sbatch --job-name="$job_name" --output "$output_path" --parsable "$slurm_script" 2>&1)
                local submit_exit=$?

                # Check for both exit code and error messages in output
                if [ $submit_exit -eq 0 ] && ! echo "$submit_output" | grep -qi "error\|invalid\|failed"; then
                    echo "✓ Job submitted: Job ID $submit_output"
                    total_jobs_submitted=$((total_jobs_submitted + 1))
                else
                    echo "✗ Failed to submit job"
                    echo "   Error: $submit_output"
                    return 1
                fi
                echo ""
            else
                echo "Warning: No slurm script found in $runtime_dir"
                echo ""
            fi
        fi
    done <<< "$runtime_dirs"

    echo "=========================================="
    echo "All pipelines submitted. Total jobs: $total_jobs_submitted"
}

# Main execution
main() {
    local pipeline_script="$1"

    echo "BioPipelines SLURM Submission Script"
    echo "===================================="
    echo ""

    # Handle help request
    if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
        usage
        return 0
    fi

    # Check if pandas is available
    #echo "Checking environment dependencies..."
    #if ! python -c "import pandas" >/dev/null 2>&1; then
    #    echo ""
    #    echo "Error: BioPipelines requires pandas to run. It is usually enough to run:"
    #    echo "   module load mamba"
    #    echo "before running the submit script. Otherwise you might have to:"
    #    echo "A. Install pandas first with pip install pandas, or"
    #    echo "B. Activate a conda environment that contains pandas"
    #    return 1
    #fi
    #echo "✓ pandas available"
    #echo ""

    # Require a pipeline script argument
    if [ -z "$pipeline_script" ]; then
        echo "Error: No pipeline script specified"
        echo ""
        usage
        return 1
    fi

    # Check if pipeline script exists
    if [ ! -f "$pipeline_script" ]; then
        echo "Error: Pipeline script not found: $pipeline_script"
        return 1
    fi

    # Run the pipeline and submit jobs
    run_pipeline_and_submit "$pipeline_script"
}

# Run main function with all arguments
main "$@"