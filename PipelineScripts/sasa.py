"""
SASA (Solvent Accessible Surface Area) tool for calculating delta SASA.

Calculates the change in solvent accessible surface area when the binder protein
is present vs absent. This metric indicates how much of the ligand surface is
buried by protein binding.

delta_SASA = SASA_ligand_alone - SASA_ligand_in_complex
"""

import os
from typing import Dict, List, Any, Optional, Union

try:
    from .base_config import BaseConfig, ToolOutput, StandardizedOutput, TableInfo
except ImportError:
    import sys
    sys.path.append(os.path.dirname(__file__))
    from base_config import BaseConfig, ToolOutput, StandardizedOutput, TableInfo


class SASA(BaseConfig):
    """
    SASA tool for calculating delta solvent accessible surface area.

    Computes how much ligand surface area is buried when bound to the protein.
    Uses PyMOL's get_area command for SASA calculations.

    delta_SASA = SASA(ligand alone) - SASA(ligand in complex)

    A higher delta_SASA indicates more ligand surface is buried by the protein,
    suggesting tighter binding.
    """

    TOOL_NAME = "SASA"
    DEFAULT_ENV = None  # Uses PyMOL

    def __init__(self,
                 structures: Union[str, List[str], ToolOutput, StandardizedOutput],
                 ligand: str,
                 dot_density: int = 4,
                 **kwargs):
        """
        Initialize SASA configuration.

        Args:
            structures: Input structures (PDB/CIF files or ToolOutput from previous tool)
            ligand: Ligand identifier/code (e.g., ":X:", "LIG", "AMX")
            dot_density: Dot density for SASA calculation (1-4, higher = more accurate)
            **kwargs: Additional parameters
        """
        self.input_structures = structures
        self.ligand = ligand
        self.dot_density = dot_density

        self.input_is_tool_output = isinstance(structures, (ToolOutput, StandardizedOutput))

        super().__init__(**kwargs)

        self._initialize_file_paths()

    def validate_params(self):
        """Validate SASA parameters."""
        if not self.input_structures:
            raise ValueError("structures parameter is required")
        if not self.ligand:
            raise ValueError("ligand parameter is required")
        if self.dot_density < 1 or self.dot_density > 4:
            raise ValueError("dot_density must be between 1 and 4")

    def _initialize_file_paths(self):
        """Initialize file paths."""
        self.results_csv = None
        self.helper_script = None

    def configure_inputs(self, pipeline_folders: Dict[str, str]):
        """Configure input structures from previous tools."""
        self.folders = pipeline_folders

        self.input_sources = {"structures": []}

        if isinstance(self.input_structures, str):
            self.input_sources["structures"] = [self.input_structures]
        elif isinstance(self.input_structures, list):
            self.input_sources["structures"] = self.input_structures
        elif hasattr(self.input_structures, 'structures'):
            structs = self.input_structures.structures
            if isinstance(structs, list):
                self.input_sources["structures"] = structs
            else:
                self.input_sources["structures"] = [structs]

        self._setup_file_paths()

    def _setup_file_paths(self):
        """Set up output file paths."""
        self.results_csv = os.path.join(self.output_folder, "sasa_analysis.csv")
        self.helper_script = os.path.join(self.folders.get('HelpScripts', 'HelpScripts'), 'pipe_sasa.py')

    def get_config_display(self) -> List[str]:
        """Get configuration display lines."""
        config_lines = super().get_config_display()
        config_lines.extend([
            f"INPUT STRUCTURES: {len(self.input_sources.get('structures', []))} files",
            f"LIGAND: {self.ligand}",
            f"DOT DENSITY: {self.dot_density}",
            f"OUTPUT: {self.results_csv}"
        ])
        return config_lines

    def generate_script(self, script_path: str) -> str:
        """Generate SASA execution script."""
        os.makedirs(self.output_folder, exist_ok=True)

        structure_files = self.input_sources["structures"]
        structure_files_str = ",".join(structure_files)

        # Normalize ligand code (remove colons for PyMOL selection)
        ligand_resn = self.ligand.replace(":", "")

        script_content = f"""#!/bin/bash
# SASA (Solvent Accessible Surface Area) execution script
# Generated by BioPipelines pipeline system

{self.generate_completion_check_header()}

echo "Running SASA analysis"
echo "Structures: {len(structure_files)} files"
echo "Ligand: {self.ligand}"
echo "Output: {self.results_csv}"

python "{self.helper_script}" \\
    --structures "{structure_files_str}" \\
    --ligand "{ligand_resn}" \\
    --output_csv "{self.results_csv}" \\
    --dot_density {self.dot_density}

if [ $? -eq 0 ]; then
    echo "SASA analysis completed successfully"
    echo "Results written to: {self.results_csv}"
else
    echo "Error: SASA analysis failed"
    exit 1
fi

{self.generate_completion_check_footer()}
"""
        return script_content

    def get_output_files(self) -> Dict[str, Any]:
        """Get expected output files after SASA execution."""
        if not hasattr(self, 'results_csv') or self.results_csv is None:
            self._setup_file_paths()

        structure_ids = self._predict_structure_ids()

        tables = {
            "sasa": TableInfo(
                name="sasa",
                path=self.results_csv,
                columns=["id", "structure", "sasa_ligand_alone", "sasa_ligand_complex", "delta_sasa"],
                description="Solvent accessible surface area analysis",
                count=len(structure_ids)
            )
        }

        return {
            "structures": [],
            "structure_ids": [],
            "compounds": [],
            "compound_ids": [],
            "sequences": [],
            "sequence_ids": [],
            "tables": tables,
            "output_folder": self.output_folder
        }

    def _predict_structure_ids(self) -> List[str]:
        """Predict structure IDs from input sources."""
        structure_ids = []
        if hasattr(self, 'input_sources') and "structures" in self.input_sources:
            for pdb_path in self.input_sources["structures"]:
                pdb_base = os.path.splitext(os.path.basename(pdb_path))[0]
                structure_ids.append(pdb_base)
        return structure_ids

    def to_dict(self) -> Dict[str, Any]:
        """Serialize configuration."""
        base_dict = super().to_dict()
        base_dict.update({
            "tool_params": {
                "ligand": self.ligand,
                "dot_density": self.dot_density,
                "input_type": "tool_output" if self.input_is_tool_output else "direct"
            }
        })
        return base_dict
